# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Tag_new_2.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import cv2
import os
import pickle
import re
import traceback
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QSize, Qt
from PyQt5.QtGui import QPixmap, QIcon
from PyQt5.QtWidgets import QTableWidgetItem, QHeaderView, QAbstractItemView, QMessageBox, QMenu, \
    QFileDialog

from backend.data_manager import DataManager
from backend.utility import is_node_in_list, ShowType, VersionType, ElementType, SearchType, \
    delete_files, WorkState, get_node_by_idx, is_xpath_matched, get_node_changes
from backend.xml_tree import parse_xml

from frontend.my_widget import MyDialog, MyLabel

from frontend import new_dialog2

# 这个引用很重要 否则图片不能正常显示
from frontend import tool_bar_resource_rc


class Ui_MainWindow(object):
    # 创建数据管理类
    data_manager = DataManager()

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        # 重新设置大小
        MainWindow.resize(1218, 700)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.splitter = QtWidgets.QSplitter(self.centralwidget)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.frame = QtWidgets.QFrame(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(22)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame.sizePolicy().hasHeightForWidth())
        self.frame.setSizePolicy(sizePolicy)
        # self.frame.setStyleSheet("QFrame\n"
        #                          "{\n"
        #                          "    background-color:green;\n"
        #                          "}")
        self.frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame.setObjectName("frame")

        # 未增加名字前的布局
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.frame)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.base_image_label = MyLabel(self.frame)
        # self.base_image_label.setStyleSheet("QLabel\n"
        #                                     "{\n"
        #                                     "    background-color:red;\n"
        #                                     "}")
        self.base_image_label.setObjectName("label")
        self.base_image_label.setMaximumSize(540 * 0.9, 960 * 0.9)

        self.horizontalLayout_2.addWidget(self.base_image_label)
        self.updated_image_label = MyLabel(self.frame)
        # self.updated_image_label.setStyleSheet("QLabel\n"
        #                                        "{\n"
        #                                        "    background-color:yellow;\n"
        #                                        "}")
        self.updated_image_label.setObjectName("label_2")

        self.base_image_label.version = VersionType.BASE.value
        self.updated_image_label.version = VersionType.UPDATED.value

        self.updated_image_label.setMaximumSize(540 * 0.9, 960 * 0.9)

        self.horizontalLayout_2.addWidget(self.updated_image_label)

        '''
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.frame)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.label_4 = QtWidgets.QLabel(self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_4.sizePolicy().hasHeightForWidth())
        self.label_4.setSizePolicy(sizePolicy)
        self.label_4.setObjectName("label_4")
        self.verticalLayout_4.addWidget(self.label_4)

        self.frame_7 = QtWidgets.QFrame(self.frame)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(5)
        sizePolicy.setHeightForWidth(self.frame_7.sizePolicy().hasHeightForWidth())
        self.frame_7.setSizePolicy(sizePolicy)
        self.frame_7.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_7.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_7.setObjectName("frame_7")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.frame_7)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")

        self.base_image_label = MyLabel(self.frame_7)
        # self.base_image_label.setStyleSheet("QLabel\n"
        #                          "{\n"
        #                          "    background-color:red;\n"
        #                          "}")
        self.base_image_label.setObjectName("label")
        self.horizontalLayout_2.addWidget(self.base_image_label)
        self.updated_image_label = MyLabel(self.frame_7)
        # self.updated_image_label.setStyleSheet("QLabel\n"
        #                            "{\n"
        #                            "    background-color:yellow;\n"
        #                            "}")
        self.updated_image_label.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.updated_image_label)
        self.verticalLayout_4.addWidget(self.frame_7)
        '''

        # 分界线
        self.frame_2 = QtWidgets.QFrame(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(5)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_2.sizePolicy().hasHeightForWidth())
        self.frame_2.setSizePolicy(sizePolicy)
        # self.frame_2.setStyleSheet("QFrame\n"
        #                            "{\n"
        #                            "    background-color:red;\n"
        #                            "    margin-top:0px;\n"
        #                            "    margin-right:0px;\n"
        #                            "    margin-bottom:0px;\n"
        #                            "    margin-left:0px;\n"
        #                            "}")
        self.frame_2.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_2.setObjectName("frame_2")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.frame_2)
        self.verticalLayout.setObjectName("verticalLayout")
        self.splitter_2 = QtWidgets.QSplitter(self.frame_2)
        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
        self.splitter_2.setObjectName("splitter_2")
        self.frame_4 = QtWidgets.QFrame(self.splitter_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(1)
        sizePolicy.setHeightForWidth(self.frame_4.sizePolicy().hasHeightForWidth())
        self.frame_4.setSizePolicy(sizePolicy)
        # self.frame_4.setStyleSheet("QFrame\n"
        #                            "{\n"
        #                            "    background-color:purple;\n"
        #                            "}")
        self.frame_4.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_4.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_4.setObjectName("frame_4")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.frame_4)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.splitter_3 = QtWidgets.QSplitter(self.frame_4)
        self.splitter_3.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_3.setObjectName("splitter_3")
        self.frame_5 = QtWidgets.QFrame(self.splitter_3)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(2)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_5.sizePolicy().hasHeightForWidth())
        self.frame_5.setSizePolicy(sizePolicy)
        # self.frame_5.setStyleSheet("QFrame\n"
        #                            "{\n"
        #                            "    background-color:green;\n"
        #                            "}")
        self.frame_5.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_5.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_5.setObjectName("frame_5")
        self.gridLayout = QtWidgets.QGridLayout(self.frame_5)
        self.gridLayout.setObjectName("gridLayout")

        self.comboBox_2 = QtWidgets.QComboBox(self.frame_5)
        self.comboBox_2.setObjectName("comboBox_2")
        self.gridLayout.addWidget(self.comboBox_2, 1, 0, 1, 1)

        self.pushButton = QtWidgets.QPushButton(self.frame_5)
        self.pushButton.setObjectName("pushButton")
        self.gridLayout.addWidget(self.pushButton, 3, 0, 1, 1)
        self.lineEdit = QtWidgets.QLineEdit(self.frame_5)
        self.lineEdit.setObjectName("lineEdit")
        self.gridLayout.addWidget(self.lineEdit, 2, 0, 1, 1)

        self.comboBox = QtWidgets.QComboBox(self.frame_5)
        self.comboBox.setObjectName("comboBox")

        self.gridLayout.addWidget(self.comboBox, 0, 0, 1, 1)
        self.pushButton_2 = QtWidgets.QPushButton(self.frame_5)
        self.pushButton_2.setObjectName("pushButton_2")
        self.gridLayout.addWidget(self.pushButton_2, 4, 0, 1, 1)
        self.pushButton_3 = QtWidgets.QPushButton(self.frame_5)
        self.pushButton_3.setObjectName("pushButton_3")
        self.gridLayout.addWidget(self.pushButton_3, 5, 0, 1, 1)
        self.pushButton_4 = QtWidgets.QPushButton(self.frame_5)
        self.pushButton_4.setObjectName("pushButton_4")
        self.gridLayout.addWidget(self.pushButton_4, 6, 0, 1, 1)
        self.pushButton_5 = QtWidgets.QPushButton(self.frame_5)
        self.pushButton_5.setObjectName("pushButton_5")
        self.gridLayout.addWidget(self.pushButton_5, 7, 0, 1, 1)
        self.frame_6 = QtWidgets.QFrame(self.splitter_3)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(4)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.frame_6.sizePolicy().hasHeightForWidth())
        self.frame_6.setSizePolicy(sizePolicy)
        # self.frame_6.setStyleSheet("QFrame\n"
        #                            "{\n"
        #                            "    background-color:green;\n"
        #                            "}")
        self.frame_6.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_6.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_6.setObjectName("frame_6")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.frame_6)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_3 = QtWidgets.QLabel(self.frame_6)
        self.label_3.setObjectName("label_3")
        self.verticalLayout_2.addWidget(self.label_3)
        self.tableWidget = QtWidgets.QTableWidget(self.frame_6)
        self.tableWidget.setObjectName("tableWidget")
        self.verticalLayout_2.addWidget(self.tableWidget)

        self.horizontalLayout_3.addWidget(self.splitter_3)
        self.frame_3 = QtWidgets.QFrame(self.splitter_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(12)
        sizePolicy.setHeightForWidth(self.frame_3.sizePolicy().hasHeightForWidth())
        self.frame_3.setSizePolicy(sizePolicy)
        # self.frame_3.setStyleSheet("QFrame\n"
        #                            "{\n"
        #                            "    background-color:green;\n"
        #                            "}")
        self.frame_3.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.frame_3.setFrameShadow(QtWidgets.QFrame.Raised)
        self.frame_3.setObjectName("frame_3")

        # self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.frame_3)
        # self.horizontalLayout_4.setObjectName("horizontalLayout_4")

        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.frame_3)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.checkBox = QtWidgets.QCheckBox(self.frame_3)
        self.checkBox.setObjectName("checkBox")
        self.verticalLayout_3.addWidget(self.checkBox)

        self.tabWidget = QtWidgets.QTabWidget(self.frame_3)
        self.tabWidget.setObjectName("tabWidget")

        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.tableWidget_2 = QtWidgets.QTableWidget(self.tab)
        self.tableWidget_2.setObjectName("tableWidget_2")
        self.tableWidget_2.setColumnCount(0)
        self.tableWidget_2.setRowCount(0)
        self.horizontalLayout_5.addWidget(self.tableWidget_2)
        self.tabWidget.addTab(self.tab, "")

        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout(self.tab_2)
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.tableWidget_3 = QtWidgets.QTableWidget(self.tab_2)
        self.tableWidget_3.setObjectName("tableWidget_3")
        self.tableWidget_3.setColumnCount(0)
        self.tableWidget_3.setRowCount(0)
        self.horizontalLayout_6.addWidget(self.tableWidget_3)
        self.tabWidget.addTab(self.tab_2, "")

        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout(self.tab_3)
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.tableWidget_4 = QtWidgets.QTableWidget(self.tab_3)
        self.tableWidget_4.setObjectName("tableWidget_4")
        self.tableWidget_4.setColumnCount(0)
        self.tableWidget_4.setRowCount(0)
        self.horizontalLayout_7.addWidget(self.tableWidget_4)
        self.tabWidget.addTab(self.tab_3, "")

        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout(self.tab_4)
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.tableWidget_5 = QtWidgets.QTableWidget(self.tab_4)
        self.tableWidget_5.setObjectName("tableWidget_5")
        self.tableWidget_5.setColumnCount(0)
        self.tableWidget_5.setRowCount(0)
        self.horizontalLayout_8.addWidget(self.tableWidget_5)
        self.tabWidget.addTab(self.tab_4, "")

        self.tab_5 = QtWidgets.QWidget()
        self.tab_5.setObjectName("tab_5")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout(self.tab_5)
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.tableWidget_6 = QtWidgets.QTableWidget(self.tab_5)
        self.tableWidget_6.setObjectName("tableWidget_6")
        self.tableWidget_6.setColumnCount(0)
        self.tableWidget_6.setRowCount(0)
        self.horizontalLayout_9.addWidget(self.tableWidget_6)
        self.tabWidget.addTab(self.tab_5, "")

        self.tab_6 = QtWidgets.QWidget()
        self.tab_6.setObjectName("tab_6")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout(self.tab_6)
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.tableWidget_7 = QtWidgets.QTableWidget(self.tab_6)
        self.tableWidget_7.setObjectName("tableWidget_7")
        self.tableWidget_7.setColumnCount(0)
        self.tableWidget_7.setRowCount(0)
        self.horizontalLayout_10.addWidget(self.tableWidget_7)
        self.tabWidget.addTab(self.tab_6, "")

        self.tab_7 = QtWidgets.QWidget()
        self.tab_7.setObjectName("tab_7")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout(self.tab_7)
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.tableWidget_8 = QtWidgets.QTableWidget(self.tab_7)
        self.tableWidget_8.setObjectName("tableWidget_8")
        self.tableWidget_8.setColumnCount(0)
        self.tableWidget_8.setRowCount(0)
        self.horizontalLayout_11.addWidget(self.tableWidget_8)
        self.tabWidget.addTab(self.tab_7, "")

        # 再增加一个 matched 列表
        self.tab_8 = QtWidgets.QWidget()
        self.tab_8.setObjectName("tab_8")
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout(self.tab_8)
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.tableWidget_9 = QtWidgets.QTableWidget(self.tab_8)
        self.tableWidget_9.setObjectName("tableWidget_9")
        self.tableWidget_9.setColumnCount(0)
        self.tableWidget_9.setRowCount(0)
        self.horizontalLayout_12.addWidget(self.tableWidget_9)
        self.tabWidget.addTab(self.tab_8, "")

        self.verticalLayout_3.addWidget(self.tabWidget)

        self.verticalLayout.addWidget(self.splitter_2)
        self.horizontalLayout.addWidget(self.splitter)

        # 在这里使用了MainWindow
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.toolBar = QtWidgets.QToolBar(MainWindow)
        self.toolBar.setObjectName("toolBar")
        MainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.toolBar)
        self.actionNew = QtWidgets.QAction(MainWindow)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(":/tool/images/create.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionNew.setIcon(icon)
        self.actionNew.setObjectName("actionNew")
        self.actionOpen = QtWidgets.QAction(MainWindow)
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(":/tool/images/open_file_2.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionOpen.setIcon(icon1)
        self.actionOpen.setObjectName("actionOpen")
        self.actionRestore = QtWidgets.QAction(MainWindow)
        icon2 = QtGui.QIcon()
        icon2.addPixmap(QtGui.QPixmap(":/tool/images/restore.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionRestore.setIcon(icon2)
        self.actionRestore.setObjectName("actionRestore")
        self.actionSave = QtWidgets.QAction(MainWindow)
        icon3 = QtGui.QIcon()
        icon3.addPixmap(QtGui.QPixmap(":/tool/images/save.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionSave.setIcon(icon3)
        self.actionSave.setObjectName("actionSave")
        self.actionSaveAs = QtWidgets.QAction(MainWindow)
        icon4 = QtGui.QIcon()
        icon4.addPixmap(QtGui.QPixmap(":/tool/images/save_file.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionSaveAs.setIcon(icon4)
        self.actionSaveAs.setObjectName("actionSaveAs")
        self.actionClear = QtWidgets.QAction(MainWindow)
        icon5 = QtGui.QIcon()
        icon5.addPixmap(QtGui.QPixmap(":/tool/images/clear.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.actionClear.setIcon(icon5)
        self.actionClear.setObjectName("actionClear")
        self.toolBar.addAction(self.actionNew)
        self.toolBar.addAction(self.actionOpen)
        self.toolBar.addAction(self.actionRestore)
        self.toolBar.addAction(self.actionSave)
        self.toolBar.addAction(self.actionSaveAs)
        self.toolBar.addAction(self.actionClear)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        # MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        # 重新设置名字
        MainWindow.setWindowTitle('Scrob UI Viewer')
        # self.label_4.setText(_translate("MainWindow", "new work"))
        self.base_image_label.setText(_translate("MainWindow", ""))
        self.updated_image_label.setText(_translate("MainWindow", ""))
        self.pushButton.setText(_translate("MainWindow", "Search"))
        self.pushButton_2.setText(_translate("MainWindow", "Move to Visible"))
        self.pushButton_3.setText(_translate("MainWindow", "Move to Removed"))
        self.pushButton_4.setText(_translate("MainWindow", "Move to Changed"))
        self.pushButton_5.setText(_translate("MainWindow", "Move to Added"))
        self.label_3.setText(_translate("MainWindow", "Element Detail"))

        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Base Visible"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "Updated Visible"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_3), _translate("MainWindow", "Removed"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_4), _translate("MainWindow", "Changed"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_5), _translate("MainWindow", "Added"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_6), _translate("MainWindow", "Base Invisible"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_7), _translate("MainWindow", "Updated Invisible"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_8), _translate("MainWindow", "Matched"))

        self.checkBox.setText(_translate("MainWindow", "Draw All"))

        self.toolBar.setWindowTitle(_translate("MainWindow", "toolBar"))
        self.actionNew.setText(_translate("MainWindow", "New"))
        self.actionNew.setToolTip(_translate("MainWindow", "New"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))
        self.actionOpen.setToolTip(_translate("MainWindow", "Open"))
        self.actionRestore.setText(_translate("MainWindow", "Restore"))
        self.actionRestore.setToolTip(_translate("MainWindow", "Restore"))
        self.actionSave.setText(_translate("MainWindow", "Save"))
        self.actionSave.setToolTip(_translate("MainWindow", "Save"))
        self.actionSaveAs.setText(_translate("MainWindow", "SaveAs"))
        self.actionSaveAs.setToolTip(_translate("MainWindow", "Save As"))
        self.actionClear.setText(_translate("MainWindow", "Clear"))
        self.actionClear.setToolTip(_translate("MainWindow", "Clear"))

        self.lineEdit.setToolTip(_translate("MainWindow", "No/bounds/Xpath"))

        self.base_image_label.setToolTip('Base Version GUI')
        self.updated_image_label.setToolTip('Updated Version GUI')

        # 设置全局样式
        window_style = '''
            QPushButton {
                font-family:Arial;
                color:white;
                background-color:rgb(14 , 150 , 254);
                border-radius:8px;
            }

            QPushButton:hover {
                background-color:rgb(104 , 137 , 255);
            }

            QPushButton:pressed {
                background-color:rgb(14 , 135 , 228);
                padding-left:3px;
                padding-top:3px;
            }

             QComboBox {
                font-family:Arial;
                font-weight:bold;
                text-align:center;
            }

            QLabel {
                font-family:Arial;
                font-weight:bold;
            }
            
            QCheckBox {
                font-family:Arial;
                font-weight:bold;
            }
            
            QTableWidget {
                text-align:center;
            }

        '''

        MainWindow.setStyleSheet(window_style)

        # 绑定事件
        self.events_bond(MainWindow)

        # 初始化组件
        self.init_gui()

    def init_gui(self):
        """
        初始化各种组件
        :return:
        """

        # 初始化各类组件
        self.init_combobox()
        self.init_table_widget()
        self.init_tab_widget()

    def init_tab_widget(self):
        """
        对tab组件进行初始化
        :return:
        """

        # 设置tabWidget样式
        # self.tabWidget.setStyleSheet("QTabBar::tab:selected{color:red;background-color:rbg(255,200,255);} ")

        # 这个也可以写在全局的样式表中
        self.tabWidget.setStyleSheet('''
            QTabBar {
                font-family:Arial;
                font-weight:bold;
            }
            QTabBar::tab:selected {
                background-color:#0e96fe;
            }
        ''')

        # 设置tab组件形状为三角形 好丑 我不要
        # self.tabWidget.setTabShape(QTabWidget.Triangular)

    def init_combobox(self):
        """
        对combobox进行初始化
        :return:
        """

        self.comboBox.addItems(['Base Version', 'Updated Version'])
        self.comboBox_2.addItems(['Leaf', 'Branch'])

    def init_table_widget(self):
        """
        对表格进行初始化
        :return:
        """

        # 设置表格1
        # 对tableWidget进行设定
        # self.tableWidget.setEditTriggers(QAbstractItemView.NoEditTriggers) 不可编辑

        # 设置列数
        self.tableWidget.setColumnCount(1)
        self.tableWidget.setRowCount(14)
        # 设置无表头
        self.tableWidget.horizontalHeader().setVisible(False)

        # 表格根据内容自动设置列宽
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)

        # 设置竖直表头
        self.tableWidget.setVerticalHeaderLabels(
            ['index', 'class', 'id', 'text', 'desc', 'width',
             'height', 'location', 'bounds', 'XPath', 'No', 'layer', 'type', 'clickable'])

        # 设置表格2 Base Visible
        self.tableWidget_2.setColumnCount(3)
        self.tableWidget_2.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_2.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        # 设置无竖直表头
        self.tableWidget_2.verticalHeader().setVisible(False)
        self.tableWidget_2.setHorizontalHeaderLabels(['index', 'Image', 'No'])
        # 设置列表中的图标大小
        self.tableWidget_2.setIconSize(QSize(300, 300))
        # 设置整行显示
        self.tableWidget_2.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_2.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格3 Updated Visible
        self.tableWidget_3.setColumnCount(3)
        self.tableWidget_3.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_3.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_3.verticalHeader().setVisible(False)
        self.tableWidget_3.setHorizontalHeaderLabels(['index', 'Image', 'No'])

        # 设置列表中的图标大小
        self.tableWidget_3.setIconSize(QSize(300, 300))
        # 设置整行显示
        self.tableWidget_3.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_3.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格4 Removed
        self.tableWidget_4.setColumnCount(4)
        # 设置自由伸展 水平方向延展 竖直方向符合内容
        self.tableWidget_4.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_4.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)

        self.tableWidget_4.verticalHeader().setVisible(False)
        self.tableWidget_4.setHorizontalHeaderLabels(['index', 'Image', 'No', 'Type'])
        # 设置列表中的图标大小
        self.tableWidget_4.setIconSize(QSize(300, 300))

        # 设置整行显示
        self.tableWidget_4.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_4.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格5 Changed
        self.tableWidget_5.setColumnCount(13)
        self.tableWidget_5.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_5.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_5.verticalHeader().setVisible(False)
        self.tableWidget_5.setHorizontalHeaderLabels(['index', 'Image', 'No', 'Type',
                                                      'Matched Image', 'Matched No', 'class',
                                                      'id', 'text', 'desc', 'size', 'location', 'color'])

        # 设置列表中的图标大小
        self.tableWidget_5.setIconSize(QSize(300, 300))

        # 设置整行显示
        self.tableWidget_5.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_5.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格6 Added
        self.tableWidget_6.setColumnCount(4)
        self.tableWidget_6.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_6.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_6.verticalHeader().setVisible(False)
        self.tableWidget_6.setHorizontalHeaderLabels(['index', 'Image', 'No', 'Type'])

        # 设置列表中的图标大小
        self.tableWidget_6.setIconSize(QSize(300, 300))

        # 设置整行显示
        self.tableWidget_6.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_6.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格7 Base Invisible
        self.tableWidget_7.setColumnCount(3)
        self.tableWidget_7.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_7.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_7.verticalHeader().setVisible(False)
        self.tableWidget_7.setHorizontalHeaderLabels(['index', 'Image', 'No'])

        # 设置列表中的图标大小
        self.tableWidget_7.setIconSize(QSize(300, 300))
        # 设置整行显示
        self.tableWidget_7.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_7.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格8 Updated Invisible
        self.tableWidget_8.setColumnCount(3)
        self.tableWidget_8.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_8.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_8.verticalHeader().setVisible(False)
        self.tableWidget_8.setHorizontalHeaderLabels(['index', 'Image', 'No'])

        # 设置列表中的图标大小
        self.tableWidget_8.setIconSize(QSize(300, 300))
        # 设置整行显示
        self.tableWidget_8.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_8.setContextMenuPolicy(Qt.CustomContextMenu)

        # 设置表格9 Matched
        self.tableWidget_9.setColumnCount(5)
        self.tableWidget_9.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget_9.verticalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.tableWidget_9.verticalHeader().setVisible(False)
        self.tableWidget_9.setHorizontalHeaderLabels(['index', 'Image', 'No', 'Matched Image', 'Matched No'])

        # 设置列表中的图标大小
        self.tableWidget_9.setIconSize(QSize(300, 300))
        # 设置整行显示
        self.tableWidget_9.setSelectionBehavior(QAbstractItemView.SelectRows)
        # 设置允许弹出上下文菜单
        self.tableWidget_9.setContextMenuPolicy(Qt.CustomContextMenu)

    def events_bond(self, MainWindow):
        """
        事件绑定函数
        :return:
        """

        # 绑定点击表格行获取元素详细信息事件 这里是从主窗口将元素信息发往label
        MainWindow.ele_signal.connect(self.base_image_label.receive_element_event)
        MainWindow.ele_signal.connect(self.updated_image_label.receive_element_event)

        # 绑定窗口关闭信号
        MainWindow.close_signal.connect(self.close_event)

        # 绑定工具栏的打开操作
        self.actionNew.triggered.connect(lambda: self.action_new_event(MainWindow))

        # 绑定工具栏保存操作
        self.actionSave.triggered.connect(lambda: self.action_save_event(MainWindow))

        # 绑定工具栏另存为操作
        self.actionSaveAs.triggered.connect(lambda: self.action_save_as_event(MainWindow)) \
 \
            # 绑定工具栏打开操作
        self.actionOpen.triggered.connect(lambda: self.action_open_event(MainWindow))

        # 绑定工具栏恢复操作
        self.actionRestore.triggered.connect(lambda: self.action_restore_event(MainWindow))

        # 绑定工具栏清空操作
        self.actionClear.triggered.connect(lambda: self.action_clear_event(MainWindow))

        # 绑定按钮的点击操作 触发展示节点信息事件
        self.base_image_label.ele_signal.connect(self.show_node_detail_event)
        self.updated_image_label.ele_signal.connect(self.show_node_detail_event)

        # 绑定show_all checkBox 事件 这里是从主窗口将信息发往label
        MainWindow.show_all_signal.connect(self.base_image_label.show_all_event)
        MainWindow.show_all_signal.connect(self.updated_image_label.show_all_event)

        # 移入 visible list 事件绑定
        self.pushButton_2.clicked.connect(lambda: self.move_to_visible_event(MainWindow))

        # 移入removed list 事件绑定
        self.pushButton_3.clicked.connect(lambda: self.move_to_removed_event(MainWindow))

        # 移入changed list 事件绑定
        self.pushButton_4.clicked.connect(lambda: self.move_to_changed_event(MainWindow))

        # 移入added list 事件绑定
        self.pushButton_5.clicked.connect(lambda: self.move_to_added_event(MainWindow))

        # base visible list 绑定右键菜单事件
        self.tableWidget_2.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_2.cursor().pos(), ShowType.BVISIBLE, MainWindow))

        # updated visible list 绑定右键菜单事件
        self.tableWidget_3.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_3.cursor().pos(), ShowType.UVISIBLE, MainWindow))

        # removed list 绑定右键菜单事件
        self.tableWidget_4.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_4.cursor().pos(), ShowType.REMOVED, MainWindow))

        # changed list 绑定右键菜单事件
        self.tableWidget_5.customContextMenuRequested.connect(
            lambda: self.generate_changed_menu_event(self.tableWidget_5.cursor().pos(), MainWindow))

        # added list 绑定右键菜单事件
        self.tableWidget_6.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_6.cursor().pos(), ShowType.ADDED, MainWindow))

        # base invisible 绑定右键菜单事件
        self.tableWidget_7.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_7.cursor().pos(), ShowType.BINVISIBLE, MainWindow))

        # updated invisible 绑定右键菜单事件
        self.tableWidget_8.customContextMenuRequested.connect(
            lambda: self.generate_normal_menu_event(self.tableWidget_8.cursor().pos(), ShowType.UINVISIBLE, MainWindow))

        # matched 绑定右键菜单事件
        self.tableWidget_9.customContextMenuRequested.connect(
            lambda: self.generate_matched_menu_event(self.tableWidget_9.cursor().pos(), MainWindow))

        # show_all check box 绑定
        # print(self.checkBox.isChecked())
        # print(self.checkBox.checkState())
        self.checkBox.stateChanged.connect(lambda: self.show_all_event(self.checkBox.isChecked(), MainWindow))

        # 改变元素类型 comboBox绑定 直接绑定label的事件
        self.comboBox_2.activated.connect(lambda:
                                          self.base_image_label.ele_type_change_event(self.comboBox_2.currentIndex()))

        self.comboBox_2.activated.connect(lambda:
                                          self.updated_image_label.ele_type_change_event(
                                              self.comboBox_2.currentIndex()))

        # 改变搜索元素版本 comboBox 绑定 直接绑定label 事件
        self.comboBox.activated.connect(lambda: self.version_change_event(self.comboBox.currentIndex()))

        # 绑定搜索事件
        self.pushButton.clicked.connect(lambda: self.search_event(MainWindow))

    def get_file_path_event(self, info_list):
        """
        获取从子窗口传来的文件路径事件
        :return:
        """
        try:

            # 信息重置
            self.data_manager.reset()
            self.initial_nodes_list()

            # 获取路径
            self.data_manager.base_image_path = info_list[0]
            self.data_manager.base_xml_path = info_list[1]
            self.data_manager.updated_image_path = info_list[2]
            self.data_manager.updated_xml_path = info_list[3]

            self.data_manager.work_directory = 'work'

            # 读取图片
            self.data_manager.base_image = cv2.imread(info_list[0])
            self.data_manager.updated_image = cv2.imread(info_list[2])

            # 在label上显示图片
            self.base_image_label.setPixmap(QPixmap(self.data_manager.base_image_path))
            # 自定义适应大小
            self.base_image_label.setScaledContents(True)

            self.updated_image_label.setPixmap(QPixmap(self.data_manager.updated_image_path))
            self.updated_image_label.setScaledContents(True)

            # 对xml树进行解析
            base_xml_tree = parse_xml(self.data_manager.base_xml_path,
                                      self.data_manager.base_image_path, VersionType.BASE.value)
            updated_xml_tree = parse_xml(self.data_manager.updated_xml_path,
                                         self.data_manager.updated_image_path, VersionType.UPDATED.value)

            # 目前是在这里和label中各存了一套数据
            # 但是数据对象都是相同的 比如base_xml_tree 其实指向的是同一个对象 里面的节点对象都是相同的
            self.data_manager.base_xml_tree = base_xml_tree
            self.data_manager.updated_xml_tree = updated_xml_tree

            self.base_image_label.xml_tree = base_xml_tree
            self.updated_image_label.xml_tree = updated_xml_tree

            # 获取图片宽度以及长度
            base_root_node = self.data_manager.base_xml_tree.nodes[0]
            updated_root_node = self.data_manager.updated_xml_tree.nodes[0]

            self.base_image_label.image_width = base_root_node.width
            self.base_image_label.image_height = base_root_node.height
            self.updated_image_label.image_width = updated_root_node.width
            self.updated_image_label.image_height = updated_root_node.height

            # 创建文件夹
            work_path_list = [self.data_manager.base_visible_path, self.data_manager.updated_visible_path,
                              self.data_manager.removed_path, self.data_manager.changed_path,
                              self.data_manager.added_path, self.data_manager.base_invisible_path,
                              self.data_manager.updated_invisible_path, self.data_manager.matched_path]

            for path in work_path_list:
                if not os.path.exists(path):
                    os.makedirs(path)

            # 初始化base visible 以及 updated visible 列表
            self.base_image_label.visible_nodes = self.base_image_label.xml_tree.leaf_nodes.copy()
            self.updated_image_label.visible_nodes = self.updated_image_label.xml_tree.leaf_nodes.copy()

            self.update_base_visible_list(False, None)
            self.update_updated_visible_list(False, None)

            # 初始化匹配元素的列表
            for node in self.data_manager.base_xml_tree.nodes:
                for tmp_node in self.updated_image_label.visible_nodes:
                    if is_xpath_matched(node, tmp_node) and tmp_node.matched_node_idx == -1:
                        node.matched_node_idx = tmp_node.idx
                        tmp_node.matched_node_idx = node.idx
                        break

            for node in self.base_image_label.visible_nodes:
                if node.matched_node_idx != -1:
                    self.base_image_label.matched_nodes.append(node)

            self.update_matched_list(False, None)

            # self.data_manager.work_state = WorkState.NEW.value 初始化成new就行
            self.data_manager.work_name = 'new'


        except Exception as e:
            print(e)
            traceback.print_exc()
            # 显示错误对话框
            Dialog = info_list[4]
            QMessageBox.critical(Dialog, 'Wrong', 'New Error.',
                                 QMessageBox.Yes)

    def action_new_event(self, MainWindow):
        """
        创建事件
        :return:
        """
        dialog = MyDialog()
        ui = new_dialog2.Ui_Dialog()
        ui.setupUi(dialog)

        # 使用子窗口信号绑定主窗口的事件
        dialog.path_signal.connect(self.get_file_path_event)
        dialog.setWindowTitle('Load UI Files')
        dialog.exec()

        # if self.data_manager.work_name == '':
        #     MainWindow.setWindowTitle('Scrob UI Viewer - new')
        MainWindow.setWindowTitle('Scrob UI Viewer - new')

    def show_node_detail_event(self, node_list):
        """
        展示节点信息
        :return:
        """

        try:
            self.data_manager.current_node = node_list[0]

            if self.data_manager.current_node.version == VersionType.BASE.value:
                self.data_manager.base_current_node = self.data_manager.current_node
            else:
                self.data_manager.updated_current_node = self.data_manager.current_node

            # 填充数据

            index_item = QTableWidgetItem(str(self.data_manager.current_node.attrib['index']))
            self.tableWidget.setItem(0, 0, index_item)

            class_item = QTableWidgetItem(self.data_manager.current_node.attrib['class'])
            self.tableWidget.setItem(0, 1, class_item)

            id_item = QTableWidgetItem(self.data_manager.current_node.attrib['resource-id'])
            self.tableWidget.setItem(0, 2, id_item)

            text_item = QTableWidgetItem(self.data_manager.current_node.attrib['text'])
            self.tableWidget.setItem(0, 3, text_item)

            desc_item = QTableWidgetItem(self.data_manager.current_node.attrib['content-desc'])
            self.tableWidget.setItem(0, 4, desc_item)

            width_item = QTableWidgetItem(str(self.data_manager.current_node.width))
            self.tableWidget.setItem(0, 5, width_item)

            height_item = QTableWidgetItem(str(self.data_manager.current_node.height))
            self.tableWidget.setItem(0, 6, height_item)

            loc_item = QTableWidgetItem('(' + str(self.data_manager.current_node.loc_x) + ',' +
                                        str(self.data_manager.current_node.loc_y) + ')')
            self.tableWidget.setItem(0, 7, loc_item)

            bounds_item = QTableWidgetItem(self.data_manager.current_node.attrib['bounds'])
            self.tableWidget.setItem(0, 8, bounds_item)

            xpath_item = QTableWidgetItem(self.data_manager.current_node.full_xpath)
            self.tableWidget.setItem(0, 9, xpath_item)

            no_item = QTableWidgetItem(str(self.data_manager.current_node.idx))
            self.tableWidget.setItem(0, 10, no_item)

            layer_item = QTableWidgetItem(str(self.data_manager.current_node.layer))
            self.tableWidget.setItem(0, 11, layer_item)

            if self.data_manager.current_node.children:
                type_item = QTableWidgetItem(ElementType.BRANCH.value)
            else:
                type_item = QTableWidgetItem(ElementType.LEAF.value)

            self.tableWidget.setItem(0, 12, type_item)

            clickable_item = QTableWidgetItem(self.data_manager.current_node.attrib['clickable'])
            self.tableWidget.setItem(0, 13, clickable_item)


        except Exception as e:
            print(e)
            traceback.print_exc()

    def move_to_visible_event(self, MainWindow):
        """
        将元素移入visible列表事件
        同时处理基础版本和更新版本
        :param MainWindow:
        :return:
        """

        if self.data_manager.current_node is not None:
            if self.data_manager.current_node.version == VersionType.BASE.value:
                if is_node_in_list(self.data_manager.current_node, self.base_image_label.visible_nodes):
                    # 显示错误对话框
                    QMessageBox.critical(MainWindow, 'Wrong',
                                         'The element is already in the base visible element list.',
                                         QMessageBox.Yes)
                else:
                    self.base_image_label.visible_nodes.append(self.data_manager.current_node)
                    self.update_base_visible_list(True, MainWindow)
                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'The element has been added to the base visible element list',
                                            QMessageBox.Yes)
            else:
                if is_node_in_list(self.data_manager.current_node, self.updated_image_label.visible_nodes):
                    # 显示错误对话框
                    QMessageBox.critical(MainWindow, 'Wrong',
                                         'The element is already in the updated visible element list.',
                                         QMessageBox.Yes)
                else:
                    self.updated_image_label.visible_nodes.append(self.data_manager.current_node)

                    self.update_updated_visible_list(True, MainWindow)

                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'The element has been added to the updated visible element list',
                                            QMessageBox.Yes)

    def move_to_removed_event(self, MainWindow):
        """
        将元素移入removed列表事件
        :return:
        """

        if (self.data_manager.current_node is not None
                and self.data_manager.current_node.version == VersionType.BASE.value):
            if is_node_in_list(self.data_manager.current_node, self.base_image_label.removed_nodes):
                # 显示错误对话框
                QMessageBox.critical(MainWindow, 'Wrong', 'The element is already in the removed element list.',
                                     QMessageBox.Yes)
            else:
                self.base_image_label.removed_nodes.append(self.data_manager.current_node)

                # print(self.base_image_label.removed_nodes)
                self.update_removed_list(True, MainWindow)
                # 显示一个消息对话框
                QMessageBox.information(MainWindow, 'Message',
                                        'The element has been added to the removed element list',
                                        QMessageBox.Yes)

    def move_to_changed_event(self, MainWindow):
        """
        将元素移入changed列表事件
        :param MainWindow:
        :return:
        """

        if (self.data_manager.current_node is not None
                and self.data_manager.current_node.version == VersionType.BASE.value):

            if is_node_in_list(self.data_manager.current_node, self.base_image_label.changed_nodes):
                # 显示错误对话框
                QMessageBox.critical(MainWindow, 'Wrong', 'The element is already in the changed element list.',
                                     QMessageBox.Yes)

            else:
                try:
                    if self.data_manager.current_node.matched_node_idx != -1:
                        tmp_node = get_node_by_idx(self.data_manager.current_node.matched_node_idx,
                                                   self.data_manager.updated_xml_tree.nodes)
                        get_node_changes(self.data_manager.current_node, tmp_node)
                except Exception as e:
                    print(e)
                    traceback.print_exc()
                self.base_image_label.changed_nodes.append(self.data_manager.current_node)
                # print(self.base_image_label.removed_nodes)
                self.update_changed_list(True, MainWindow)
                # 显示一个消息对话框
                QMessageBox.information(MainWindow, 'Message',
                                        'The element has been added to the changed element list',
                                        QMessageBox.Yes)

    def move_to_added_event(self, MainWindow):
        """
        将元素移入added列表事件
        :param MainWindow:
        :return:
        """

        if (self.data_manager.current_node is not None
                and self.data_manager.current_node.version == VersionType.UPDATED.value):
            if is_node_in_list(self.data_manager.current_node, self.updated_image_label.added_nodes):
                # 显示错误对话框
                QMessageBox.critical(MainWindow, 'Wrong', 'The element is already in the added element list.',
                                     QMessageBox.Yes)
            else:
                self.updated_image_label.added_nodes.append(self.data_manager.current_node)
                # print(self.base_image_label.removed_nodes)
                self.update_added_list(True, MainWindow)
                # 显示一个消息对话框
                QMessageBox.information(MainWindow, 'Message',
                                        'The element has been added to the added element list',
                                        QMessageBox.Yes)

    def update_base_visible_list(self, change_flag, MainWindow):
        """
        更新 base visible 列表
        :return:
        """

        # 表明不是初始化 而是变化
        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        self.tableWidget_2.setRowCount(len(self.base_image_label.visible_nodes))
        row_count = 0
        for node in self.base_image_label.visible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()

            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.base_visible_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            no_item = QTableWidgetItem(str(node.idx))

            count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            self.tableWidget_2.setItem(row_count, 0, count_item)
            self.tableWidget_2.setItem(row_count, 1, image_item)
            self.tableWidget_2.setItem(row_count, 2, no_item)

            row_count += 1

        self.tableWidget_2.update()

    def update_updated_visible_list(self, change_flag, MainWindow):
        """
        更新 updated visible 列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        try:
            row_count = 0
            self.tableWidget_3.setRowCount(len(self.updated_image_label.visible_nodes))
            for node in self.updated_image_label.visible_nodes:
                x1, y1, x2, y2 = node.parse_bounds()

                cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

                cropped_img_path = self.data_manager.updated_visible_path + '/' + str(node.idx) + '.png'

                if not os.path.exists(cropped_img_path):
                    cv2.imwrite(cropped_img_path, cropped_img)

                count_item = QTableWidgetItem(str(row_count + 1))
                icon = QIcon(cropped_img_path)
                image_item = QTableWidgetItem(icon, '')
                no_item = QTableWidgetItem(str(node.idx))

                count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
                no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

                self.tableWidget_3.setItem(row_count, 0, count_item)
                self.tableWidget_3.setItem(row_count, 1, image_item)
                self.tableWidget_3.setItem(row_count, 2, no_item)

                row_count += 1

            self.tableWidget_3.update()
        except Exception as e:
            traceback.print_exc()
            print(e)

    def update_removed_list(self, change_flag, MainWindow):
        """
        更新removed列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        row_count = 0
        self.tableWidget_4.setRowCount(len(self.base_image_label.removed_nodes))
        for node in self.base_image_label.removed_nodes:
            x1, y1, x2, y2 = node.parse_bounds()

            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.removed_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            no_item = QTableWidgetItem(str(node.idx))

            if node.children:
                type_item = QTableWidgetItem(ElementType.BRANCH.value)

            else:
                type_item = QTableWidgetItem(ElementType.LEAF.value)

            count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            type_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            self.tableWidget_4.setItem(row_count, 0, count_item)
            self.tableWidget_4.setItem(row_count, 1, image_item)
            self.tableWidget_4.setItem(row_count, 2, no_item)
            self.tableWidget_4.setItem(row_count, 3, type_item)

            row_count += 1

        self.tableWidget_4.update()

    def update_changed_list(self, change_flag, MainWindow):
        """
        更新changed列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        row_count = 0
        self.tableWidget_5.setRowCount(len(self.base_image_label.changed_nodes))
        for node in self.base_image_label.changed_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.changed_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            if node.matched_node_idx != -1:
                matched_node = get_node_by_idx(node.matched_node_idx, self.updated_image_label.xml_tree.nodes)
                x1, y1, x2, y2 = matched_node.parse_bounds()
                cropped_matched_img = self.data_manager.updated_image[y1:y2, x1:x2]
                cropped_matched_img_path = (self.data_manager.changed_path + '/' + str(node.idx) +
                                            '-matched-' + str(matched_node.idx) + '.png')

                if not os.path.exists(cropped_matched_img_path):
                    cv2.imwrite(cropped_matched_img_path, cropped_matched_img)

                matched_icon = QIcon(cropped_matched_img_path)
                matched_image_item = QTableWidgetItem(matched_icon, '')

            else:
                matched_image_item = QTableWidgetItem('')

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            matched_no_item = QTableWidgetItem(str(node.matched_node_idx))
            class_item = QTableWidgetItem(str(node.changed_attrs['class']))
            id_item = QTableWidgetItem(str(node.changed_attrs['resource-id']))
            text_item = QTableWidgetItem(str(node.changed_attrs['text']))
            desc_item = QTableWidgetItem(str(node.changed_attrs['content-desc']))
            size_item = QTableWidgetItem(str(node.changed_attrs['size']))
            location_item = QTableWidgetItem(str(node.changed_attrs['location']))
            color_item = QTableWidgetItem(str(node.changed_attrs['color']))
            # list_item = QTableWidgetItem(str(node.is_in_list))

            if node.children:
                type_item = QTableWidgetItem(ElementType.BRANCH.value)

            else:
                type_item = QTableWidgetItem(ElementType.LEAF.value)

            no_item = QTableWidgetItem(str(node.idx))

            items = [count_item, image_item, no_item, type_item, matched_image_item, matched_no_item, class_item,
                     id_item, text_item, desc_item, size_item,
                     location_item, color_item]

            for i in range(len(items)):
                self.tableWidget_5.setItem(row_count, i, items[i])

                if i != 1:
                    items[i].setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            row_count += 1

        self.tableWidget_5.update()

    def update_added_list(self, change_flag, MainWindow):
        """
        更新added列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        row_count = 0
        self.tableWidget_6.setRowCount(len(self.updated_image_label.added_nodes))
        for node in self.updated_image_label.added_nodes:
            x1, y1, x2, y2 = node.parse_bounds()

            cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.added_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            no_item = QTableWidgetItem(str(node.idx))

            if node.children:
                type_item = QTableWidgetItem(ElementType.BRANCH.value)

            else:
                type_item = QTableWidgetItem(ElementType.LEAF.value)

            count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            type_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            self.tableWidget_6.setItem(row_count, 0, count_item)
            self.tableWidget_6.setItem(row_count, 1, image_item)
            self.tableWidget_6.setItem(row_count, 2, no_item)
            self.tableWidget_6.setItem(row_count, 3, type_item)

            row_count += 1

        self.tableWidget_6.update()

    def update_base_invisible_list(self, change_flag, MainWindow):
        """
        更新base版本不可见的元素列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        row_count = 0
        self.tableWidget_7.setRowCount(len(self.base_image_label.invisible_nodes))
        # 然后利用这些元素更新列表
        for node in self.base_image_label.invisible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.base_invisible_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            no_item = QTableWidgetItem(str(node.idx))

            count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            self.tableWidget_7.setItem(row_count, 0, count_item)
            self.tableWidget_7.setItem(row_count, 1, image_item)
            self.tableWidget_7.setItem(row_count, 2, no_item)

            row_count += 1

        self.tableWidget_7.update()

    def update_updated_invisible_list(self, change_flag, MainWindow):
        """
        更新updated版本不可见元素列表
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        self.tableWidget_8.setRowCount(len(self.updated_image_label.invisible_nodes))
        row_count = 0
        # 然后利用这些元素更新列表
        for node in self.updated_image_label.invisible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()

            cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

            cropped_img_path = self.data_manager.updated_invisible_path + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            count_item = QTableWidgetItem(str(row_count + 1))
            icon = QIcon(cropped_img_path)
            image_item = QTableWidgetItem(icon, '')
            no_item = QTableWidgetItem(str(node.idx))

            count_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            no_item.setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

            self.tableWidget_8.setItem(row_count, 0, count_item)
            self.tableWidget_8.setItem(row_count, 1, image_item)
            self.tableWidget_8.setItem(row_count, 2, no_item)

            row_count += 1

        self.tableWidget_8.update()

    def update_matched_list(self, change_flag, MainWindow):
        """
        更新匹配元素列表
        :param change_flag:
        :param MainWindow:
        :return:
        """

        if change_flag:
            self.update_work_state(change_flag, MainWindow)

        self.tableWidget_9.setRowCount(len(self.base_image_label.matched_nodes))
        row_count = 0

        # 利用元素更新列表
        for node in self.base_image_label.matched_nodes:
            if node.matched_node_idx != -1:
                # 读取匹配上的元素的图片
                matched_node = get_node_by_idx(node.matched_node_idx, self.updated_image_label.xml_tree.nodes)
                x1, y1, x2, y2 = node.parse_bounds()
                cropped_img = self.data_manager.base_image[y1:y2, x1:x2]
                x1, y1, x2, y2 = matched_node.parse_bounds()
                cropped_matched_img = self.data_manager.updated_image[y1:y2, x1:x2]

                cropped_img_path = self.data_manager.matched_path + '/' + str(node.idx) + '.png'
                cropped_matched_img_path = (self.data_manager.matched_path + '/' + str(node.idx) +
                                            '-matched-' + str(matched_node.idx) + '.png')

                # 创建匹配上的图片
                if not os.path.exists(cropped_img_path):
                    cv2.imwrite(cropped_img_path, cropped_img)

                if not os.path.exists(cropped_matched_img_path):
                    cv2.imwrite(cropped_matched_img_path, cropped_matched_img)

                count_item = QTableWidgetItem(str(row_count + 1))
                icon = QIcon(cropped_img_path)
                image_item = QTableWidgetItem(icon, '')
                no_item = QTableWidgetItem(str(node.idx))
                matched_no_item = QTableWidgetItem(str(node.matched_node_idx))
                matched_icon = QIcon(cropped_matched_img_path)
                matched_image_item = QTableWidgetItem(matched_icon, '')

                items = [count_item, image_item, no_item, matched_image_item, matched_no_item]

                for i in range(len(items)):
                    self.tableWidget_9.setItem(row_count, i, items[i])
                    if i != 1:
                        items[i].setTextAlignment(Qt.AlignHCenter | Qt.AlignVCenter)

                row_count += 1

        self.tableWidget_9.update()

    def generate_normal_menu_event(self, pos, show_type, MainWindow):
        """
        显示列表上下文菜单
        这个函数也许可以复用 通过传递的参数不同以实现复用
        :return:
        """

        try:

            nodes_list = []
            table_widget = None
            # version = VersionType.BASE.value

            if show_type.value == ShowType.BVISIBLE.value:
                nodes_list = self.base_image_label.visible_nodes
                table_widget = self.tableWidget_2

            if show_type.value == ShowType.UVISIBLE.value:
                nodes_list = self.updated_image_label.visible_nodes
                table_widget = self.tableWidget_3
                # version = VersionType.UPDATED.value

            if show_type.value == ShowType.REMOVED.value:
                nodes_list = self.base_image_label.removed_nodes
                table_widget = self.tableWidget_4

            if show_type.value == ShowType.ADDED.value:
                nodes_list = self.updated_image_label.added_nodes
                table_widget = self.tableWidget_6
                # version = VersionType.UPDATED.value

            if show_type.value == ShowType.BINVISIBLE.value:
                nodes_list = self.base_image_label.invisible_nodes
                table_widget = self.tableWidget_7

            if show_type.value == ShowType.UINVISIBLE.value:
                nodes_list = self.updated_image_label.invisible_nodes
                table_widget = self.tableWidget_8
                # version = VersionType.UPDATED.value

            if len(nodes_list) != 0:
                menu = QMenu()
                delete_item = menu.addAction('delete')
                locate_item = menu.addAction('locate')
                refresh_item = menu.addAction('refresh')

                flag = False
                if show_type.value == ShowType.BVISIBLE.value or show_type.value == ShowType.UVISIBLE.value:
                    # 增加一个导出不可见项目
                    generate_invisible_item = menu.addAction('update invisible list')
                    mark_list_ele_item = menu.addAction('mark list elements')
                    flag = True

                if show_type.value == ShowType.BVISIBLE.value:
                    # 增加移入 removed列表 以及 移入 changed 列表项目
                    add_to_removed_item = menu.addAction('add to removed list')
                    add_to_changed_item = menu.addAction('add to changed list')

                if show_type.value == ShowType.UVISIBLE.value:
                    # 增加移入 added 列表
                    add_to_added_item = menu.addAction('add to added list')

                # 这里是直接传鼠标参数进来 所以无需映射到全局了
                # screen_pos = self.tableWidget_4.mapToGlobal(pos)
                action = menu.exec(pos)

                if action == delete_item:
                    # 获得所点击的行 然后打印其中的内容
                    # 这里选中的其实是每一个单元格
                    answer = QMessageBox.question(MainWindow, 'Delete'
                                                  , 'Do you want to delete these elements?',
                                                  QMessageBox.Yes | QMessageBox.No)

                    # 找出所选出的行
                    selected_rows = set()
                    if answer == QMessageBox.Yes:
                        for item in table_widget.selectedItems():
                            selected_rows.add(item.row())

                        begin_index = min(selected_rows)
                        end_index = max(selected_rows)

                        # 更新节点列表 将节点删除
                        del nodes_list[begin_index: end_index + 1]

                        # 在视图上进行删除
                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)
                        delete_num = end_row - begin_row + 1

                        for i in range(delete_num):
                            table_widget.removeRow(begin_row)

                        self.update_work_state(True, MainWindow)

                        # 更新列表
                        # 这里都可以不需要 直接调用api删除行即可，它自己会刷新的。
                        # self.updated_removed_list()

                if action == locate_item:
                    # 因为这里是选中了一行的两个单元格
                    if len(table_widget.selectedItems()) != table_widget.columnCount():
                        # 显示错误对话框
                        QMessageBox.critical(MainWindow, 'Wrong', 'Only one element could be selected to locate',
                                             QMessageBox.Yes)
                    else:
                        # 获取选择的行
                        selected_row = table_widget.selectedItems()[0].row()

                        # 获取元素
                        current_node = None

                        for i in range(len(nodes_list)):
                            if i == selected_row:
                                current_node = nodes_list[i]
                                break

                        # current_node.version = version
                        # 更新上部列表以及左部分标签
                        self.show_node_detail_event([current_node])
                        # 更新点击事件所在的标签
                        info = [current_node]
                        MainWindow.ele_signal.emit(info)

                if action == refresh_item:
                    self.update_all_lists()

                if flag and action == generate_invisible_item:
                    if show_type.value == ShowType.BVISIBLE.value:
                        # 首先把不可见的元素找出来
                        self.base_image_label.invisible_nodes = []
                        for node in self.base_image_label.xml_tree.leaf_nodes:
                            if not node.children and not is_node_in_list(node, self.base_image_label.visible_nodes):
                                self.base_image_label.invisible_nodes.append(node)

                        self.update_base_invisible_list(True, MainWindow)

                    if show_type.value == ShowType.UVISIBLE.value:
                        # 首先把不可见的元素找出来
                        self.updated_image_label.invisible_nodes = []
                        for node in self.updated_image_label.xml_tree.leaf_nodes:
                            if not node.children and not is_node_in_list(node, self.updated_image_label.visible_nodes):
                                self.updated_image_label.invisible_nodes.append(node)

                        self.update_updated_invisible_list(True, MainWindow)

                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'The corresponding invisible element list has been updated.',
                                            QMessageBox.Yes)

                    self.update_work_state(True, MainWindow)

                if flag and action == mark_list_ele_item:
                    if show_type.value == ShowType.BVISIBLE.value:
                        # 找出所选出的行
                        selected_rows = set()
                        for item in table_widget.selectedItems():
                            selected_rows.add(item.row())

                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)

                        # 遍历每一行的每个单元格 获取元素
                        for i in range(begin_row, end_row + 1):
                            tmp_node = self.base_image_label.visible_nodes[i]
                            for node in self.data_manager.base_xml_tree.nodes:
                                if tmp_node.idx == node.idx:
                                    node.is_in_list = True
                        # 显示一个消息对话框
                        QMessageBox.information(MainWindow, 'Message',
                                                'Mark list elements successfully.',
                                                QMessageBox.Yes)

                    if show_type.value == ShowType.UVISIBLE.value:
                        # 找出所选出的行
                        selected_rows = set()
                        for item in table_widget.selectedItems():
                            selected_rows.add(item.row())

                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)

                        # 遍历每一行的每个单元格 获取元素
                        for i in range(begin_row, end_row + 1):
                            tmp_node = self.updated_image_label.visible_nodes[i]
                            for node in self.data_manager.updated_xml_tree.nodes:
                                if tmp_node.idx == node.idx:
                                    node.is_in_list = True
                        # 显示一个消息对话框
                        QMessageBox.information(MainWindow, 'Message',
                                                'Mark list elements successfully.',
                                                QMessageBox.Yes)

                if show_type.value == ShowType.BVISIBLE.value:

                    # 如果是移入 removed
                    if action == add_to_removed_item:
                        answer = QMessageBox.question(MainWindow, 'Add'
                                                      , 'Do you want to add these elements to removed list?',
                                                      QMessageBox.Yes | QMessageBox.No)

                        if answer == QMessageBox.Yes:
                            # 找出所选出的行
                            selected_rows = set()
                            for item in table_widget.selectedItems():
                                selected_rows.add(item.row())

                            begin_row = min(selected_rows)
                            end_row = max(selected_rows)

                            # 遍历每一行的每个单元格 获取元素的变化信息
                            for i in range(begin_row, end_row + 1):
                                tmp_node = self.base_image_label.visible_nodes[i]
                                if not is_node_in_list(tmp_node, self.base_image_label.removed_nodes):
                                    self.base_image_label.removed_nodes.append(tmp_node)

                            self.update_removed_list(True, MainWindow)

                            # 显示一个消息对话框
                            QMessageBox.information(MainWindow, 'Message',
                                                    "Add elements to removed list successfully.",
                                                    QMessageBox.Yes)

                    if action == add_to_changed_item:
                        answer = QMessageBox.question(MainWindow, 'Add'
                                                      , 'Do you want to add these elements to changed list?',
                                                      QMessageBox.Yes | QMessageBox.No)

                        if answer == QMessageBox.Yes:
                            selected_rows = set()
                            for item in table_widget.selectedItems():
                                selected_rows.add(item.row())

                            begin_row = min(selected_rows)
                            end_row = max(selected_rows)

                            # 遍历每一行的每个单元格 获取元素的变化信息
                            for i in range(begin_row, end_row + 1):
                                tmp_node = self.base_image_label.visible_nodes[i]
                                if not is_node_in_list(tmp_node, self.base_image_label.changed_nodes):
                                    self.base_image_label.changed_nodes.append(tmp_node)

                            self.update_changed_list(True, MainWindow)

                            # 显示一个消息对话框
                            QMessageBox.information(MainWindow, 'Message',
                                                    "Add elements to changed list successfully.",
                                                    QMessageBox.Yes)

                if show_type.value == ShowType.UVISIBLE.value:
                    # 如果是移入 added
                    if action == add_to_added_item:
                        answer = QMessageBox.question(MainWindow, 'Add'
                                                      , 'Do you want to add these elements to added list?',
                                                      QMessageBox.Yes | QMessageBox.No)

                        if answer == QMessageBox.Yes:
                            # 找出选中的行
                            selected_rows = set()
                            for item in table_widget.selectedItems():
                                selected_rows.add(item.row())

                            begin_row = min(selected_rows)
                            end_row = max(selected_rows)

                            # 遍历每一行的每个单元格 获取元素的变化信息
                            for i in range(begin_row, end_row + 1):
                                tmp_node = self.updated_image_label.visible_nodes[i]
                                if not is_node_in_list(tmp_node, self.updated_image_label.added_nodes):
                                    self.updated_image_label.added_nodes.append(tmp_node)

                            self.update_added_list(True, MainWindow)

                            # 显示一个消息对话框
                            QMessageBox.information(MainWindow, 'Message',
                                                    "Add elements to added list successfully.",
                                                    QMessageBox.Yes)

        except Exception as e:
            print(e)
            traceback.print_exc()

    def generate_changed_menu_event(self, pos, MainWindow):
        """
        显示changed列表的上下文菜单
        :param pos:
        :param MainWindow:
        :return:
        """

        nodes_list = self.base_image_label.changed_nodes
        # 对象可以通过赋值传递 但是列表不行
        table_widget = self.tableWidget_5

        if len(self.base_image_label.changed_nodes) != 0:
            menu = QMenu()
            delete_item = menu.addAction('delete')
            locate_item = menu.addAction('locate')
            save_item = menu.addAction('save')
            refresh_item = menu.addAction('refresh')

            # 这里是直接传鼠标参数进来 所以无需映射到全局了
            # screen_pos = self.tableWidget_4.mapToGlobal(pos)
            action = menu.exec(pos)

            if action == delete_item:
                # 获得所点击的行 然后打印其中的内容
                # 这里选中的其实是每一个单元格
                answer = QMessageBox.question(MainWindow, 'Delete'
                                              , 'Do you want to delete these elements?',
                                              QMessageBox.Yes | QMessageBox.No)

                if answer == QMessageBox.Yes:
                    # 找出所选出的行
                    selected_rows = set()
                    for item in table_widget.selectedItems():
                        selected_rows.add(item.row())

                    begin_index = min(selected_rows)
                    end_index = max(selected_rows)

                    # 更新节点列表 将节点删除
                    del nodes_list[begin_index: end_index + 1]

                    # 在视图上进行删除
                    begin_row = min(selected_rows)
                    end_row = max(selected_rows)
                    delete_num = end_row - begin_row + 1

                    for i in range(delete_num):
                        table_widget.removeRow(begin_row)

                    self.update_work_state(True, MainWindow)

            if action == locate_item:
                # 因为这里是选中了一行的九个单元格
                if len(table_widget.selectedItems()) != self.tableWidget_5.columnCount():
                    # 显示错误对话框
                    QMessageBox.critical(MainWindow, 'Wrong', 'Only one element could be selected to locate',
                                         QMessageBox.Yes)
                else:
                    # 获取选择的行
                    selected_row = table_widget.selectedItems()[0].row()

                    # 获取元素
                    current_node = None

                    for i in range(len(nodes_list)):
                        if i == selected_row:
                            current_node = nodes_list[i]
                            break
                    try:
                        # 更新上部列表以及左部分标签
                        self.show_node_detail_event([current_node])
                        # 更新点击事件所在的标签
                        info = [current_node]
                        MainWindow.ele_signal.emit(info)
                    except Exception as e:
                        print(e)

            # 如果选中了save按钮 则根据表格输入来保存变化节点的状态
            if action == save_item:

                try:

                    answer = QMessageBox.question(MainWindow, 'Save'
                                                  , 'Do you want to save these elements?',
                                                  QMessageBox.Yes | QMessageBox.No)

                    if answer == QMessageBox.Yes:
                        # 找出所选出的行
                        selected_rows = set()
                        if answer == QMessageBox.Yes:
                            for item in table_widget.selectedItems():
                                selected_rows.add(item.row())

                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)

                        # 遍历每一行的每个单元格 获取元素的变化信息
                        for i in range(begin_row, end_row + 1):
                            tmp_node = self.base_image_label.changed_nodes[i]
                            matched_no_item = self.tableWidget_5.item(i, 5)
                            class_item = self.tableWidget_5.item(i, 6)
                            id_item = self.tableWidget_5.item(i, 7)
                            text_item = self.tableWidget_5.item(i, 8)
                            desc_item = self.tableWidget_5.item(i, 9)
                            size_item = self.tableWidget_5.item(i, 10)
                            location_item = self.tableWidget_5.item(i, 11)
                            color_item = self.tableWidget_5.item(i, 12)
                            # list_item = self.tableWidget_5.item(i, 13)

                            tmp_node.matched_node_idx = int(matched_no_item.text())
                            tmp_node.changed_attrs['class'] = int(class_item.text())
                            tmp_node.changed_attrs['resource-id'] = int(id_item.text())
                            tmp_node.changed_attrs['text'] = int(text_item.text())
                            tmp_node.changed_attrs['content-desc'] = int(desc_item.text())
                            tmp_node.changed_attrs['size'] = int(size_item.text())
                            tmp_node.changed_attrs['location'] = int(location_item.text())
                            tmp_node.changed_attrs['color'] = int(color_item.text())
                            # tmp_node.is_in_list = list_item.text()

                        # 显示一个消息对话框
                        QMessageBox.information(MainWindow, 'Message',

                                                "Save elements' information successfully.",
                                                QMessageBox.Yes)

                        self.update_work_state(True, MainWindow)


                except Exception as e:
                    print(e)
                    print(traceback.print_exc())
                    # 显示错误对话框
                    QMessageBox.critical(MainWindow, 'Wrong', 'Save Error.',
                                         QMessageBox.Yes)

            if action == refresh_item:
                self.update_all_lists()

    def generate_matched_menu_event(self, pos, MainWindow):
        """
        显示matched列表的上下文菜单
        :param pos:
        :param MainWindow:
        :return:
        """

        try:
            nodes_list = self.base_image_label.matched_nodes
            table_widget = self.tableWidget_9

            if len(self.base_image_label.matched_nodes) != 0:
                menu = QMenu()
                delete_item = menu.addAction('delete')
                locate_item = menu.addAction('locate')
                refresh_item = menu.addAction('refresh')
                add_to_changed_item = menu.addAction('add to changed list')
                add_item = menu.addAction('add located elements here')
                update_removed_and_added_item = menu.addAction('update removed and added list')

                action = menu.exec(pos)

                if action == delete_item:
                    # 获得所点击的行 然后打印其中的内容
                    # 这里选中的其实是每一个单元格
                    answer = QMessageBox.question(MainWindow, 'Delete'
                                                  , 'Do you want to delete these elements?',
                                                  QMessageBox.Yes | QMessageBox.No)

                    if answer == QMessageBox.Yes:
                        # 找出所选的行
                        selected_rows = set()
                        for item in table_widget.selectedItems():
                            selected_rows.add(item.row())

                        begin_index = min(selected_rows)
                        end_index = max(selected_rows)

                        # 更新节点列表 将节点删除
                        del nodes_list[begin_index: end_index + 1]

                        # 在视图上进行删除
                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)
                        delete_num = end_row - begin_row + 1

                        for i in range(delete_num):
                            table_widget.removeRow(begin_row)

                        self.update_work_state(True, MainWindow)

                if action == locate_item:
                    # 因为这里是选中了一行的九个单元格
                    if len(table_widget.selectedItems()) != self.tableWidget_9.columnCount():
                        # 显示错误对话框
                        QMessageBox.critical(MainWindow, 'Wrong', 'Only one element could be selected to locate',
                                             QMessageBox.Yes)
                    else:
                        # 获取选择的行
                        selected_row = table_widget.selectedItems()[0].row()

                        # 获取元素
                        current_node = None

                        for i in range(len(nodes_list)):
                            if i == selected_row:
                                current_node = nodes_list[i]
                                break
                        try:
                            # 更新上部列表以及左部分标签
                            self.show_node_detail_event([current_node])
                            # 更新点击事件所在的标签
                            info = [current_node]
                            MainWindow.ele_signal.emit(info)
                        except Exception as e:
                            print(e)

                if action == refresh_item:
                    self.update_all_lists()

                if action == add_to_changed_item:
                    answer = QMessageBox.question(MainWindow, 'Add'
                                                  , 'Do you want to add these elements to changed list?',
                                                  QMessageBox.Yes | QMessageBox.No)

                    if answer == QMessageBox.Yes:
                        selected_rows = set()
                        for item in table_widget.selectedItems():
                            selected_rows.add(item.row())

                        begin_row = min(selected_rows)
                        end_row = max(selected_rows)

                        for i in range(begin_row, end_row + 1):
                            tmp_node = self.base_image_label.matched_nodes[i]
                            matched_node = get_node_by_idx(tmp_node.matched_node_idx,
                                                           self.updated_image_label.xml_tree.nodes)
                            get_node_changes(tmp_node, matched_node)
                            self.base_image_label.changed_nodes.append(tmp_node)

                        self.update_changed_list(True, MainWindow)
                        # 显示一个消息对话框
                        QMessageBox.information(MainWindow, 'Message',
                                                "Add elements to changed list successfully.",
                                                QMessageBox.Yes)

                if action == add_item:
                    current_node = self.data_manager.base_current_node
                    if is_node_in_list(current_node, self.base_image_label.matched_nodes):
                        QMessageBox.critical(MainWindow,
                                             'Wrong', 'The located elements are already in the matched list',
                                             QMessageBox.Yes)
                    else:
                        matched_node = self.data_manager.updated_current_node
                        current_node.matched_node_idx = matched_node.idx
                        matched_node.matched_node_idx = current_node.idx
                        self.base_image_label.matched_nodes.append(current_node)
                        self.update_matched_list(True, MainWindow)

                if action == update_removed_and_added_item:
                    # 将所有的可视但是未匹配的节点加入removed以及added
                    for node in self.base_image_label.visible_nodes:
                        if not is_node_in_list(node, self.base_image_label.matched_nodes):
                            if not is_node_in_list(node, self.base_image_label.removed_nodes):
                                self.base_image_label.removed_nodes.append(node)

                    idx_list = []
                    for node in self.base_image_label.matched_nodes:
                        idx_list.append(node.matched_node_idx)

                    for node in self.updated_image_label.visible_nodes:
                        if node.idx not in idx_list and not is_node_in_list(node, self.updated_image_label.added_nodes):
                            self.updated_image_label.added_nodes.append(node)

                    self.update_removed_list(True, MainWindow)
                    self.update_added_list(True, MainWindow)

                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'The removed list and added list has been updated.',
                                            QMessageBox.Yes)
            else:
                menu = QMenu()
                add_item = menu.addAction('add located elements here')
                action = menu.exec(pos)
                if action == add_item:
                    current_node = self.data_manager.base_current_node
                    if is_node_in_list(current_node, self.base_image_label.matched_nodes):
                        QMessageBox.critical(MainWindow,
                                             'Wrong', 'The located elements are already in the matched list',
                                             QMessageBox.Yes)
                    else:
                        matched_node = self.data_manager.updated_current_node
                        current_node.matched_node_idx = matched_node.idx
                        matched_node.matched_node_idx = current_node.idx
                        self.base_image_label.matched_nodes.append(current_node)
                        self.update_matched_list(True, MainWindow)




        except Exception as e:
            print(e)
            traceback.print_exc()

    def show_all_event(self, is_checked, MainWindow):
        """
        show_all check box 选中事件
        :param state:
        :return:
        """

        print(is_checked)

        # 获取选中状态
        show_all = is_checked
        show_type = ShowType.BVISIBLE.value

        # 获取当前的tab是哪个
        tab_text = self.tabWidget.tabText(self.tabWidget.currentIndex())

        if tab_text == 'Base Visible':
            show_type = ShowType.BVISIBLE.value

        if tab_text == 'Updated Visible':
            show_type = ShowType.UVISIBLE.value

        if tab_text == 'Removed':
            show_type = ShowType.REMOVED.value

        if tab_text == 'Changed':
            show_type = ShowType.CHANGED.value

        if tab_text == 'Added':
            show_type = ShowType.ADDED.value

        if tab_text == 'Base Invisible':
            show_type = ShowType.BINVISIBLE.value

        if tab_text == 'Updated Invisible':
            show_type = ShowType.UINVISIBLE.value

        if tab_text == 'Matched':
            show_type = ShowType.MATCHED.value

        # 发送信号给label
        MainWindow.show_all_signal.emit([show_all, show_type])

    def search_event(self, MainWindow):
        """
        搜索按钮事件
        :return:
        """
        try:

            search_type = SearchType.ILLEGAL.value

            search_text = self.lineEdit.text()

            # 使用正则表达式来判断类型

            # 首先匹配数字
            num_pattern = re.compile('\d*')
            result = re.match(num_pattern, search_text)

            if result is not None:
                search_type = SearchType.NO.value

            # 之后匹配bounds
            bounds_pattern = re.compile("((\\[)([0-9])+,([0-9])+(\\])){2}")
            result = re.match(bounds_pattern, search_text)

            if result is not None:
                search_type = SearchType.BOUNDS.value

            if result is None:
                search_type = SearchType.XPATH.value

            # 在自己这进行搜索 后发消息给label进行显示
            target_node = None
            if self.data_manager.search_version == VersionType.BASE.value:
                search_nodes = self.data_manager.base_xml_tree.nodes
            else:
                search_nodes = self.data_manager.updated_xml_tree.nodes

            # 如果是通过no搜索
            if search_type == SearchType.NO.value:
                for node in search_nodes:
                    if node.idx == int(search_text):
                        target_node = node
                        break

                if target_node is not None:
                    self.show_node_detail_event([target_node])
                    # 发消息给label进行显示
                    MainWindow.ele_signal.emit([target_node])

            # 如果是根据bounds搜索
            if search_type == SearchType.BOUNDS.value:
                node_list = []
                for node in search_nodes:
                    if node.attrib['bounds'] == search_text:
                        node_list.append(node)

                if len(node_list) == 1:
                    self.show_node_detail_event(node_list)
                    # 发消息给label进行显示
                    MainWindow.ele_signal.emit(node_list)

            # 如果是根据xpath搜索
            if search_type == SearchType.XPATH.value:
                for node in search_nodes:
                    # print(node.xpath)
                    if node.full_xpath == search_text:
                        target_node = node
                        break

                if target_node is not None:
                    self.show_node_detail_event([target_node])
                    # 发消息给label进行显示
                    MainWindow.ele_signal.emit([target_node])
        except Exception as e:
            print(e)
            traceback.print_exc()

    def version_change_event(self, index):
        """
        改变要搜索的元素版本事件
        :param index:
        :return:
        """

        if index == 0:
            self.data_manager.search_version = VersionType.BASE.value

        if index == 1:
            self.data_manager.search_version = VersionType.UPDATED.value

    def action_save_event(self, MainWindow):
        """
        保存项目事件
        :return:
        """

        try:
            if self.data_manager.work_name != '':
                # 首先打开文件框选择需要保存的目录
                if self.data_manager.save_directory == '':
                    file_name = QFileDialog.getExistingDirectory(MainWindow, "Choose Save Diretory")
                    if file_name != '':
                        self.data_manager.save_directory = file_name
                        self.data_manager.work_name = file_name
                        # delete_files(file_name)
                        self.save_information_event(MainWindow)

                        # 显示一个消息对话框
                        QMessageBox.information(MainWindow, 'Message',
                                                'Save work successfully.',
                                                QMessageBox.Yes)
                        self.update_work_state(False, MainWindow)

                else:
                    # delete_files(self.data_manager.save_directory)
                    self.save_information_event(MainWindow)

                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'Save work successfully.',
                                            QMessageBox.Yes)
                    self.update_work_state(False, MainWindow)

            # else:
            #     QMessageBox.critical(MainWindow, 'Wrong', 'No Work to Save.',
            #                          QMessageBox.Yes)


        except Exception as e:
            print(e)
            print(traceback.print_exc())
            QMessageBox.critical(MainWindow, 'Wrong', 'Save Work Error.',
                                 QMessageBox.Yes)

    def action_save_as_event(self, MainWindow):
        """
        另存为事件
        :param MainWindow:
        :return:
        """
        try:
            if self.data_manager.work_name != '':
                file_name = QFileDialog.getExistingDirectory(MainWindow, "Choose Save Diretory")
                if file_name != '':
                    self.data_manager.save_directory = file_name
                    self.data_manager.work_name = file_name
                    # delete_files(file_name)
                    self.save_information_event(MainWindow)
                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'Save work successfully.',
                                            QMessageBox.Yes)
                    self.update_work_state(False, MainWindow)

            # else:
            #     QMessageBox.critical(MainWindow, 'Wrong', 'No Work to Save.',
            #                          QMessageBox.Yes)

        except Exception as e:
            print(e)
            print(traceback.print_exc())
            QMessageBox.critical(MainWindow, 'Wrong', 'Save Work Error.',
                                 QMessageBox.Yes)

    def save_information_event(self, MainWindow):
        """
        保存中的细节事件
        :return:
        """

        dir = self.data_manager.save_directory

        res_dir = dir + '/res'
        base_visible_dir = dir + '/base_visible'
        base_invisible_dir = dir + '/base_invisible'
        updated_visible_dir = dir + '/updated_visible'
        updated_invisible_dir = dir + '/updated_invisible'
        removed_dir = dir + '/removed'
        changed_dir = dir + '/changed'
        added_dir = dir + '/added'
        matched_dir = dir + '/matched'

        dir_list = [res_dir, base_visible_dir, base_invisible_dir,
                    updated_visible_dir, updated_invisible_dir,
                    removed_dir, changed_dir, added_dir, matched_dir]

        for tmp_dir in dir_list:
            if not os.path.exists(tmp_dir):
                os.makedirs(tmp_dir)

        # 首先保存图片 使用cv2进行保存 实际上是进行copy
        cv2.imwrite(res_dir + '/base_image.png', self.data_manager.base_image)
        cv2.imwrite(res_dir + '/updated_image.png', self.data_manager.updated_image)

        # 保存xml_tree
        base_xml_tree = pickle.dumps(self.data_manager.base_xml_tree)
        with open(res_dir + '/base_xml_tree', 'wb') as f:
            f.write(base_xml_tree)

        updated_xml_tree = pickle.dumps(self.data_manager.updated_xml_tree)
        with open(res_dir + '/updated_xml_tree', 'wb') as f:
            f.write(updated_xml_tree)

        # 保存各类节点

        # 保存 base visible 节点
        base_visible_nodes = pickle.dumps(self.base_image_label.visible_nodes)
        with open(base_visible_dir + '/base_visible_nodes', 'wb') as f:
            f.write(base_visible_nodes)

        for node in self.base_image_label.visible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = base_visible_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存 updated visible 节点
        updated_visible_nodes = pickle.dumps(self.updated_image_label.visible_nodes)
        with open(updated_visible_dir + '/updated_visible_nodes', 'wb') as f:
            f.write(updated_visible_nodes)

        for node in self.updated_image_label.visible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

            cropped_img_path = updated_visible_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存 base invisible 节点
        base_invisible_nodes = pickle.dumps(self.base_image_label.invisible_nodes)
        with open(base_invisible_dir + '/base_invisible_nodes', 'wb') as f:
            f.write(base_invisible_nodes)

        for node in self.base_image_label.invisible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = base_invisible_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存updated invisible 节点
        updated_invisible_nodes = pickle.dumps(self.updated_image_label.invisible_nodes)
        with open(updated_invisible_dir + '/updated_invisible_nodes', 'wb') as f:
            f.write(updated_invisible_nodes)

        for node in self.updated_image_label.invisible_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

            cropped_img_path = updated_invisible_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存removed 节点
        removed_nodes = pickle.dumps(self.base_image_label.removed_nodes)
        with open(removed_dir + '/removed_nodes', 'wb') as f:
            f.write(removed_nodes)

        for node in self.base_image_label.removed_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = removed_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存 changed 节点
        changed_nodes = pickle.dumps(self.base_image_label.changed_nodes)
        with open(changed_dir + '/changed_nodes', 'wb') as f:
            f.write(changed_nodes)

        for node in self.base_image_label.changed_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]

            cropped_img_path = changed_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存增加的节点
        added_nodes = pickle.dumps(self.updated_image_label.added_nodes)
        with open(added_dir + '/added_nodes', 'wb') as f:
            f.write(added_nodes)

        for node in self.updated_image_label.added_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.updated_image[y1:y2, x1:x2]

            cropped_img_path = added_dir + '/' + str(node.idx) + '.png'

            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

        # 保存匹配的节点
        matched_nodes = pickle.dumps(self.base_image_label.matched_nodes)
        with open(matched_dir + '/matched_nodes', 'wb') as f:
            f.write(matched_nodes)

        for node in self.base_image_label.matched_nodes:
            x1, y1, x2, y2 = node.parse_bounds()
            cropped_img = self.data_manager.base_image[y1:y2, x1:x2]
            cropped_img_path = matched_dir + '/' + str(node.idx) + '.png'
            if not os.path.exists(cropped_img_path):
                cv2.imwrite(cropped_img_path, cropped_img)

            matched_node = get_node_by_idx(node.matched_node_idx, self.updated_image_label.xml_tree.nodes)
            cropped_matched_img = self.data_manager.updated_image[y1:y2, x1:x2]
            cropped_matched_img_path = (self.data_manager.matched_path + '/' + str(node.idx) +
                                        '-matched-' + str(matched_node.idx) + '.png')
            if not os.path.exists(cropped_matched_img_path):
                cv2.imwrite(cropped_matched_img_path, cropped_matched_img)

    def action_open_event(self, MainWindow):
        """
        打开工作目录事件
        :return:
        """

        try:

            if MainWindow.work_state == WorkState.CHANGE.value:
                reply = QMessageBox.question(MainWindow, 'Message',
                                             'The current work has been modified. Do you want to '
                                             'save changes?', QMessageBox.Yes |
                                             QMessageBox.No | QMessageBox.Cancel)

                if reply == QMessageBox.Yes:
                    # 发送窗口关闭信号
                    self.close_event(['yes', MainWindow])

            # 选择目录
            dir = ''
            file_name = QFileDialog.getExistingDirectory(MainWindow, "Choose Open Diretory")
            if file_name != '':
                # 信息重置
                self.data_manager.reset()
                self.initial_nodes_list()
                dir = file_name
                res_dir = dir + '/res'
                base_visible_dir = dir + '/base_visible'
                base_invisible_dir = dir + '/base_invisible'
                updated_visible_dir = dir + '/updated_visible'
                updated_invisible_dir = dir + '/updated_invisible'
                removed_dir = dir + '/removed'
                changed_dir = dir + '/changed'
                added_dir = dir + '/added'
                matched_dir = dir + '/matched'

                # 获取路径
                self.data_manager.base_image_path = res_dir + '/base_image.png'
                self.data_manager.updated_image_path = res_dir + '/updated_image.png'

                # 读取图片
                self.data_manager.base_image = cv2.imread(res_dir + '/base_image.png')
                self.data_manager.updated_image = cv2.imread(res_dir + '/updated_image.png')

                # 在label上显示图片
                self.base_image_label.setPixmap(QPixmap(self.data_manager.base_image_path))
                # 自定义适应大小
                self.base_image_label.setScaledContents(True)

                self.updated_image_label.setPixmap(QPixmap(self.data_manager.updated_image_path))
                self.updated_image_label.setScaledContents(True)

                # 读取xml树
                f = open(res_dir + '/base_xml_tree', 'rb')
                self.data_manager.base_xml_tree = pickle.load(f)
                self.base_image_label.xml_tree = self.data_manager.base_xml_tree
                f.close()

                f = open(res_dir + '/updated_xml_tree', 'rb')
                self.data_manager.updated_xml_tree = pickle.load(f)
                self.updated_image_label.xml_tree = self.data_manager.updated_xml_tree
                f.close()

                # 获取图片宽度以及长度
                base_root_node = self.data_manager.base_xml_tree.nodes[0]
                updated_root_node = self.data_manager.updated_xml_tree.nodes[0]

                self.base_image_label.image_width = base_root_node.width
                self.base_image_label.image_height = base_root_node.height
                self.updated_image_label.image_width = updated_root_node.width
                self.updated_image_label.image_height = updated_root_node.height

                # 读取各类节点
                f = open(base_visible_dir + '/base_visible_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.base_visible_nodes = pickle.load(f)
                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.base_visible_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.base_image_label.visible_nodes = self.data_manager.base_visible_nodes.copy()
                f.close()

                f = open(base_invisible_dir + '/base_invisible_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.base_invisible_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.base_invisible_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.base_image_label.invisible_nodes = self.data_manager.base_invisible_nodes.copy()
                f.close()

                f = open(updated_visible_dir + '/updated_visible_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.updated_visible_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.updated_visible_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.updated_image_label.visible_nodes = self.data_manager.updated_visible_nodes.copy()
                f.close()

                f = open(updated_invisible_dir + '/updated_invisible_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.updated_invisible_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.updated_invisible_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.updated_image_label.invisible_nodes = self.data_manager.updated_invisible_nodes.copy()
                f.close()

                # 读取各类节点
                f = open(removed_dir + '/removed_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.removed_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.removed_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.base_image_label.removed_nodes = self.data_manager.removed_nodes.copy()
                f.close()

                # 读取各类节点
                f = open(changed_dir + '/changed_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.changed_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.changed_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.base_image_label.changed_nodes = self.data_manager.changed_nodes.copy()
                f.close()

                f = open(added_dir + '/added_nodes', 'rb')
                # 两个分别读取的是不同的对象
                self.data_manager.added_nodes = pickle.load(f)

                # 兼容matched_node_idx 和matched_node_no
                for node in self.data_manager.added_nodes:
                    if not hasattr(node, 'matched_node_idx'):
                        node.matched_node_idx = node.matched_node_no

                self.updated_image_label.added_nodes = self.data_manager.added_nodes.copy()
                f.close()

                try:
                    f = open(matched_dir + '/matched_nodes', 'rb')
                    # 两个分别读取的是不同的对象
                    self.data_manager.matched_nodes = pickle.load(f)
                    # 兼容matched_node_idx 和matched_node_no
                    for node in self.data_manager.matched_nodes:
                        if not hasattr(node, 'matched_node_idx'):
                            node.matched_node_idx = node.matched_node_no
                    self.base_image_label.matched_nodes = self.data_manager.matched_nodes.copy()

                    f.close()
                except Exception as e:
                    print(e)

                # 更新各类节点列表
                self.update_all_lists()

                self.data_manager.work_state = WorkState.REMAIN.value
                MainWindow.work_state = WorkState.REMAIN.value
                self.data_manager.work_name = file_name
                self.data_manager.save_directory = file_name

                MainWindow.setWindowTitle('Scrob UI Viewer - ' + self.data_manager.work_name)


        except Exception as e:
            print(e)
            print(traceback.print_exc())
            QMessageBox.critical(MainWindow, 'Wrong', 'Open Work Error.',
                                 QMessageBox.Yes)

    def update_work_state(self, change_flag, MainWindow):
        """
        对当前项目的状态进行更新
        Mainwindow 的work_state 的状态与 data_manager.work_state的状态保持一致
        :return:
        """

        # 发生变化操作
        if change_flag:
            # 如果是打开项目
            if self.data_manager.work_state == WorkState.REMAIN.value:
                MainWindow.work_state = WorkState.CHANGE.value
                self.data_manager.work_state = WorkState.CHANGE.value
                MainWindow.setWindowTitle('Scrob UI Viewer - ' + self.data_manager.work_name + '*')
            else:
                # 如果是新建项目
                self.data_manager.work_state = WorkState.CHANGE.value
                MainWindow.work_state = WorkState.CHANGE.value
                MainWindow.setWindowTitle('Scrob UI Viewer - ' + self.data_manager.work_name + '*')

        # 保存操作
        else:
            self.data_manager.work_state = WorkState.REMAIN.value
            MainWindow.work_state = WorkState.REMAIN.value
            MainWindow.setWindowTitle('Scrob UI Viewer - ' + self.data_manager.work_name)

    def close_event(self, info_list):
        """
        窗口关闭事件
        :return:
        """

        reply = info_list[0]
        MainWindow = info_list[1]
        # 判断返回值，如果点击的是Yes按钮，我们就关闭组件和应用，否则就忽略关闭事件
        if reply == 'yes':

            # 如果是新项目
            if self.data_manager.work_name == 'new':
                self.action_save_as_event(MainWindow)

            else:
                # 是老项目
                self.action_save_event(MainWindow)

        delete_files(self.data_manager.work_directory)

    def action_restore_event(self, MainWindow):
        """
        恢复事件
        :param MainWindow:
        :return:
        """

        if self.data_manager.work_name != '':
            reply = QMessageBox.question(MainWindow, 'Message', 'Do you want to restore the work?',
                                         QMessageBox.Yes | QMessageBox.No)

            if reply == QMessageBox.Yes:

                # 如果是新项目
                if self.data_manager.work_name == 'new':
                    # 那么直接将所有节点设置为初始化状态
                    self.base_image_label.visible_nodes = self.base_image_label.xml_tree.leaf_nodes.copy()
                    self.base_image_label.invisible_nodes = []
                    self.updated_image_label.visible_nodes = self.updated_image_label.xml_tree.leaf_nodes.copy()
                    self.updated_image_label.invisible_nodes = []
                    self.base_image_label.removed_nodes = []
                    self.base_image_label.changed_nodes = []
                    self.updated_image_label.added_nodes = []
                    self.base_image_label.matched_nodes = []

                    self.update_all_lists()

                else:
                    # 那么是老项目
                    self.base_image_label.visible_nodes = self.data_manager.base_visible_nodes.copy()
                    self.base_image_label.invisible_nodes = self.data_manager.base_invisible_nodes.copy()
                    self.updated_image_label.visible_nodes = self.data_manager.updated_visible_nodes.copy()
                    self.updated_image_label.invisible_nodes = self.data_manager.updated_invisible_nodes.copy()
                    self.base_image_label.removed_nodes = self.data_manager.removed_nodes.copy()
                    self.base_image_label.changed_nodes = self.data_manager.changed_nodes.copy()
                    self.updated_image_label.added_nodes = self.data_manager.added_nodes.copy()
                    self.base_image_label.matched_nodes = self.data_manager.matched_nodes.copy()

                    self.update_all_lists()

                # 显示一个消息对话框
                QMessageBox.information(MainWindow, 'Message',
                                        'Restore work successfully.',
                                        QMessageBox.Yes)

    def action_clear_event(self, MainWindow):
        """
        清空事件
        :return:
        """

        try:

            if self.data_manager.work_name != '':

                reply = QMessageBox.question(MainWindow, 'Message', 'Do you want to clear the work?',
                                             QMessageBox.Yes | QMessageBox.No)

                if reply == QMessageBox.Yes:

                    # 如果是新项目
                    if self.data_manager.work_name == 'new':
                        # 那么直接将所有节点设置为初始化状态
                        self.initial_nodes_list()

                    else:
                        # 那么是老项目
                        self.initial_nodes_list()

                    # 显示一个消息对话框
                    QMessageBox.information(MainWindow, 'Message',
                                            'Clear work successfully.',
                                            QMessageBox.Yes)

        except Exception as e:
            print(e)
            print(traceback.print_exc())

    def update_all_lists(self):
        """
        更新所有节点的列表
        :return:
        """

        self.update_base_visible_list(False, None)
        self.update_base_invisible_list(False, None)
        self.update_updated_visible_list(False, None)
        self.update_updated_invisible_list(False, None)
        self.update_removed_list(False, None)
        self.update_changed_list(False, None)
        self.update_added_list(False, None)
        self.update_matched_list(False, None)

    def initial_nodes_list(self):
        """
        将列表中的节点进行还原
        同时清空工作文件
        :return:
        """

        self.base_image_label.visible_nodes = []
        self.base_image_label.invisible_nodes = []
        self.updated_image_label.visible_nodes = []
        self.updated_image_label.invisible_nodes = []
        self.base_image_label.removed_nodes = []
        self.base_image_label.changed_nodes = []
        self.updated_image_label.added_nodes = []
        self.base_image_label.matched_nodes = []

        self.update_all_lists()

        delete_files(self.data_manager.work_directory)

